module.exports = [
"[project]/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "registerBackend",
    ()=>registerBackend,
    "resolveBackendAndExecutionProviders",
    ()=>resolveBackendAndExecutionProviders
]);
const backends = new Map();
const backendsSortedByPriority = [];
const registerBackend = (name, backend, priority)=>{
    if (backend && typeof backend.init === 'function' && typeof backend.createInferenceSessionHandler === 'function') {
        const currentBackend = backends.get(name);
        if (currentBackend === undefined) {
            backends.set(name, {
                backend,
                priority
            });
        } else if (currentBackend.priority > priority) {
            // same name is already registered with a higher priority. skip registeration.
            return;
        } else if (currentBackend.priority === priority) {
            if (currentBackend.backend !== backend) {
                throw new Error(`cannot register backend "${name}" using priority ${priority}`);
            }
        }
        if (priority >= 0) {
            const i = backendsSortedByPriority.indexOf(name);
            if (i !== -1) {
                backendsSortedByPriority.splice(i, 1);
            }
            for(let i = 0; i < backendsSortedByPriority.length; i++){
                if (backends.get(backendsSortedByPriority[i]).priority <= priority) {
                    backendsSortedByPriority.splice(i, 0, name);
                    return;
                }
            }
            backendsSortedByPriority.push(name);
        }
        return;
    }
    throw new TypeError('not a valid backend');
};
/**
 * Try to resolve and initialize a backend.
 *
 * @param backendName - the name of the backend.
 * @returns the backend instance if resolved and initialized successfully, or an error message if failed.
 */ const tryResolveAndInitializeBackend = async (backendName)=>{
    const backendInfo = backends.get(backendName);
    if (!backendInfo) {
        return 'backend not found.';
    }
    if (backendInfo.initialized) {
        return backendInfo.backend;
    } else if (backendInfo.aborted) {
        return backendInfo.error;
    } else {
        const isInitializing = !!backendInfo.initPromise;
        try {
            if (!isInitializing) {
                backendInfo.initPromise = backendInfo.backend.init(backendName);
            }
            await backendInfo.initPromise;
            backendInfo.initialized = true;
            return backendInfo.backend;
        } catch (e) {
            if (!isInitializing) {
                backendInfo.error = `${e}`;
                backendInfo.aborted = true;
            }
            return backendInfo.error;
        } finally{
            delete backendInfo.initPromise;
        }
    }
};
const resolveBackendAndExecutionProviders = async (options)=>{
    // extract backend hints from session options
    const eps = options.executionProviders || [];
    const backendHints = eps.map((i)=>typeof i === 'string' ? i : i.name);
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    // try to resolve and initialize all requested backends
    let backend;
    const errors = [];
    const availableBackendNames = new Set();
    for (const backendName of backendNames){
        const resolveResult = await tryResolveAndInitializeBackend(backendName);
        if (typeof resolveResult === 'string') {
            errors.push({
                name: backendName,
                err: resolveResult
            });
        } else {
            if (!backend) {
                backend = resolveResult;
            }
            if (backend === resolveResult) {
                availableBackendNames.add(backendName);
            }
        }
    }
    // if no backend is available, throw error.
    if (!backend) {
        throw new Error(`no available backend found. ERR: ${errors.map((e)=>`[${e.name}] ${e.err}`).join(', ')}`);
    }
    // for each explicitly requested backend, if it's not available, output warning message.
    for (const { name, err } of errors){
        if (backendHints.includes(name)) {
            // eslint-disable-next-line no-console
            console.warn(`removing requested execution provider "${name}" from session options because it is not available: ${err}`);
        }
    }
    const filteredEps = eps.filter((i)=>availableBackendNames.has(typeof i === 'string' ? i : i.name));
    return [
        backend,
        new Proxy(options, {
            get: (target, prop)=>{
                if (prop === 'executionProviders') {
                    return filteredEps;
                }
                return Reflect.get(target, prop);
            }
        })
    ];
}; //# sourceMappingURL=backend-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)"); //# sourceMappingURL=backend.js.map
;
}),
"[project]/node_modules/onnxruntime-common/dist/esm/version.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// This file is generated by /js/scripts/update-version.ts
// Do not modify file content manually.
__turbopack_context__.s([
    "version",
    ()=>version
]);
const version = '1.19.0'; //# sourceMappingURL=version.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/env-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "env",
    ()=>env
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/version.js [app-ssr] (ecmascript)");
;
let logLevelValue = 'warning';
const env = {
    wasm: {},
    webgl: {},
    webgpu: {},
    versions: {
        common: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$version$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["version"]
    },
    set logLevel (value){
        if (value === undefined) {
            return;
        }
        if (typeof value !== 'string' || [
            'verbose',
            'info',
            'warning',
            'error',
            'fatal'
        ].indexOf(value) === -1) {
            throw new Error(`Unsupported logging level: ${value}`);
        }
        logLevelValue = value;
    },
    get logLevel () {
        return logLevelValue;
    }
};
// set property 'logLevel' so that they can be correctly transferred to worker by `postMessage()`.
Object.defineProperty(env, 'logLevel', {
    enumerable: true
}); //# sourceMappingURL=env-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "env",
    ()=>env
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/env-impl.js [app-ssr] (ecmascript)");
;
const env = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"]; //# sourceMappingURL=env.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * implementation of Tensor.toDataURL()
 */ __turbopack_context__.s([
    "tensorToDataURL",
    ()=>tensorToDataURL,
    "tensorToImageData",
    ()=>tensorToImageData
]);
const tensorToDataURL = (tensor, options)=>{
    const canvas = typeof document !== 'undefined' ? document.createElement('canvas') : new OffscreenCanvas(1, 1);
    canvas.width = tensor.dims[3];
    canvas.height = tensor.dims[2];
    const pixels2DContext = canvas.getContext('2d');
    if (pixels2DContext != null) {
        // Default values for height and width & format
        let width;
        let height;
        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {
            width = tensor.dims[2];
            height = tensor.dims[3];
        } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
        }
        const inputformat = options?.format !== undefined ? options.format : 'RGB';
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = [
                255,
                255,
                255,
                255
            ];
        } else {
            if (typeof norm.mean === 'number') {
                normMean = [
                    norm.mean,
                    norm.mean,
                    norm.mean,
                    norm.mean
                ];
            } else {
                normMean = [
                    norm.mean[0],
                    norm.mean[1],
                    norm.mean[2],
                    0
                ];
                if (norm.mean[3] !== undefined) {
                    normMean[3] = norm.mean[3];
                }
            }
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = [
                0,
                0,
                0,
                0
            ];
        } else {
            if (typeof norm.bias === 'number') {
                normBias = [
                    norm.bias,
                    norm.bias,
                    norm.bias,
                    norm.bias
                ];
            } else {
                normBias = [
                    norm.bias[0],
                    norm.bias[1],
                    norm.bias[2],
                    0
                ];
                if (norm.bias[3] !== undefined) {
                    normBias[3] = norm.bias[3];
                }
            }
        }
        const stride = height * width;
        // Default pointer assignments
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGBA') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
        } else if (inputformat === 'RGB') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
        } else if (inputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
        }
        for(let i = 0; i < height; i++){
            for(let j = 0; j < width; j++){
                const R = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value
                const G = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value
                const B = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value
                const A = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value
                // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                pixels2DContext.fillStyle = 'rgba(' + R + ',' + G + ',' + B + ',' + A + ')';
                pixels2DContext.fillRect(j, i, 1, 1);
            }
        }
        if ('toDataURL' in canvas) {
            return canvas.toDataURL();
        } else {
            throw new Error('toDataURL is not supported');
        }
    } else {
        throw new Error('Can not access image data');
    }
};
const tensorToImageData = (tensor, options)=>{
    const pixels2DContext = typeof document !== 'undefined' ? document.createElement('canvas').getContext('2d') : new OffscreenCanvas(1, 1).getContext('2d');
    let image;
    if (pixels2DContext != null) {
        // Default values for height and width & format
        let width;
        let height;
        let channels;
        if (options?.tensorLayout !== undefined && options.tensorLayout === 'NHWC') {
            width = tensor.dims[2];
            height = tensor.dims[1];
            channels = tensor.dims[3];
        } else {
            width = tensor.dims[3];
            height = tensor.dims[2];
            channels = tensor.dims[1];
        }
        const inputformat = options !== undefined ? options.format !== undefined ? options.format : 'RGB' : 'RGB';
        const norm = options?.norm;
        let normMean;
        let normBias;
        if (norm === undefined || norm.mean === undefined) {
            normMean = [
                255,
                255,
                255,
                255
            ];
        } else {
            if (typeof norm.mean === 'number') {
                normMean = [
                    norm.mean,
                    norm.mean,
                    norm.mean,
                    norm.mean
                ];
            } else {
                normMean = [
                    norm.mean[0],
                    norm.mean[1],
                    norm.mean[2],
                    255
                ];
                if (norm.mean[3] !== undefined) {
                    normMean[3] = norm.mean[3];
                }
            }
        }
        if (norm === undefined || norm.bias === undefined) {
            normBias = [
                0,
                0,
                0,
                0
            ];
        } else {
            if (typeof norm.bias === 'number') {
                normBias = [
                    norm.bias,
                    norm.bias,
                    norm.bias,
                    norm.bias
                ];
            } else {
                normBias = [
                    norm.bias[0],
                    norm.bias[1],
                    norm.bias[2],
                    0
                ];
                if (norm.bias[3] !== undefined) {
                    normBias[3] = norm.bias[3];
                }
            }
        }
        const stride = height * width;
        if (options !== undefined) {
            if (options.format !== undefined && channels === 4 && options.format !== 'RGBA' || channels === 3 && options.format !== 'RGB' && options.format !== 'BGR') {
                throw new Error('Tensor format doesn\'t match input tensor dims');
            }
        }
        // Default pointer assignments
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
        // Updating the pointer assignments based on the input image format
        if (inputformat === 'RGBA') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
            aTensorPointer = stride * 3;
        } else if (inputformat === 'RGB') {
            rTensorPointer = 0;
            gTensorPointer = stride;
            bTensorPointer = stride * 2;
        } else if (inputformat === 'RBG') {
            rTensorPointer = 0;
            bTensorPointer = stride;
            gTensorPointer = stride * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for(let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++){
            image.data[rImagePointer] = (tensor.data[rTensorPointer++] - normBias[0]) * normMean[0]; // R value
            image.data[gImagePointer] = (tensor.data[gTensorPointer++] - normBias[1]) * normMean[1]; // G value
            image.data[bImagePointer] = (tensor.data[bTensorPointer++] - normBias[2]) * normMean[2]; // B value
            image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (tensor.data[aTensorPointer++] - normBias[3]) * normMean[3]; // A value
        }
    } else {
        throw new Error('Can not access image data');
    }
    return image;
}; //# sourceMappingURL=tensor-conversion-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "bufferToTensor",
    ()=>bufferToTensor,
    "tensorFromGpuBuffer",
    ()=>tensorFromGpuBuffer,
    "tensorFromImage",
    ()=>tensorFromImage,
    "tensorFromPinnedBuffer",
    ()=>tensorFromPinnedBuffer,
    "tensorFromTexture",
    ()=>tensorFromTexture
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)");
;
const bufferToTensor = (buffer, options)=>{
    if (buffer === undefined) {
        throw new Error('Image buffer must be defined');
    }
    if (options.height === undefined || options.width === undefined) {
        throw new Error('Image height and width must be defined');
    }
    if (options.tensorLayout === 'NHWC') {
        throw new Error('NHWC Tensor layout is not supported yet');
    }
    const { height, width } = options;
    const norm = options.norm ?? {
        mean: 255,
        bias: 0
    };
    let normMean;
    let normBias;
    if (typeof norm.mean === 'number') {
        normMean = [
            norm.mean,
            norm.mean,
            norm.mean,
            norm.mean
        ];
    } else {
        normMean = [
            norm.mean[0],
            norm.mean[1],
            norm.mean[2],
            norm.mean[3] ?? 255
        ];
    }
    if (typeof norm.bias === 'number') {
        normBias = [
            norm.bias,
            norm.bias,
            norm.bias,
            norm.bias
        ];
    } else {
        normBias = [
            norm.bias[0],
            norm.bias[1],
            norm.bias[2],
            norm.bias[3] ?? 0
        ];
    }
    const inputformat = options.format !== undefined ? options.format : 'RGBA';
    // default value is RGBA since imagedata and HTMLImageElement uses it
    const outputformat = options.tensorFormat !== undefined ? options.tensorFormat !== undefined ? options.tensorFormat : 'RGB' : 'RGB';
    const stride = height * width;
    const float32Data = outputformat === 'RGBA' ? new Float32Array(stride * 4) : new Float32Array(stride * 3);
    // Default pointer assignments
    let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
    let rTensorPointer = 0, gTensorPointer = stride, bTensorPointer = stride * 2, aTensorPointer = -1;
    // Updating the pointer assignments based on the input image format
    if (inputformat === 'RGB') {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
    }
    // Updating the pointer assignments based on the output tensor format
    if (outputformat === 'RGBA') {
        aTensorPointer = stride * 3;
    } else if (outputformat === 'RBG') {
        rTensorPointer = 0;
        bTensorPointer = stride;
        gTensorPointer = stride * 2;
    } else if (outputformat === 'BGR') {
        bTensorPointer = 0;
        gTensorPointer = stride;
        rTensorPointer = stride * 2;
    }
    for(let i = 0; i < stride; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step){
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias[0]) / normMean[0];
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias[1]) / normMean[1];
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias[2]) / normMean[2];
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
            float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias[3]) / normMean[3];
        }
    }
    // Float32Array -> ort.Tensor
    const outputTensor = outputformat === 'RGBA' ? new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]('float32', float32Data, [
        1,
        4,
        height,
        width
    ]) : new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]('float32', float32Data, [
        1,
        3,
        height,
        width
    ]);
    return outputTensor;
};
const tensorFromImage = async (image, options)=>{
    // checking the type of image object
    const isHTMLImageEle = typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement;
    const isImageDataEle = typeof ImageData !== 'undefined' && image instanceof ImageData;
    const isImageBitmap = typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap;
    const isString = typeof image === 'string';
    let data;
    let bufferToTensorOptions = options ?? {};
    const createCanvas = ()=>{
        if (typeof document !== 'undefined') {
            return document.createElement('canvas');
        } else if (typeof OffscreenCanvas !== 'undefined') {
            return new OffscreenCanvas(1, 1);
        } else {
            throw new Error('Canvas is not supported');
        }
    };
    const createCanvasContext = (canvas)=>{
        if (canvas instanceof HTMLCanvasElement) {
            return canvas.getContext('2d');
        } else if (canvas instanceof OffscreenCanvas) {
            return canvas.getContext('2d');
        } else {
            return null;
        }
    };
    // filling and checking image configuration options
    if (isHTMLImageEle) {
        // HTMLImageElement - image object - format is RGBA by default
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
            let height = image.height;
            let width = image.width;
            if (options !== undefined && options.resizedHeight !== undefined && options.resizedWidth !== undefined) {
                height = options.resizedHeight;
                width = options.resizedWidth;
            }
            if (options !== undefined) {
                bufferToTensorOptions = options;
                if (options.tensorFormat !== undefined) {
                    throw new Error('Image input config format must be RGBA for HTMLImageElement');
                } else {
                    bufferToTensorOptions.tensorFormat = 'RGBA';
                }
                bufferToTensorOptions.height = height;
                bufferToTensorOptions.width = width;
            } else {
                bufferToTensorOptions.tensorFormat = 'RGBA';
                bufferToTensorOptions.height = height;
                bufferToTensorOptions.width = width;
            }
            pixels2DContext.drawImage(image, 0, 0);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
        } else {
            throw new Error('Can not access image data');
        }
    } else if (isImageDataEle) {
        let height;
        let width;
        if (options !== undefined && options.resizedWidth !== undefined && options.resizedHeight !== undefined) {
            height = options.resizedHeight;
            width = options.resizedWidth;
        } else {
            height = image.height;
            width = image.width;
        }
        if (options !== undefined) {
            bufferToTensorOptions = options;
        }
        bufferToTensorOptions.format = 'RGBA';
        bufferToTensorOptions.height = height;
        bufferToTensorOptions.width = width;
        if (options !== undefined) {
            const tempCanvas = createCanvas();
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = createCanvasContext(tempCanvas);
            if (pixels2DContext != null) {
                pixels2DContext.putImageData(image, 0, 0);
                data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
                throw new Error('Can not access image data');
            }
        } else {
            data = image.data;
        }
    } else if (isImageBitmap) {
        // ImageBitmap - image object - format must be provided by user
        if (options === undefined) {
            throw new Error('Please provide image config with format for Imagebitmap');
        }
        const canvas = createCanvas();
        canvas.width = image.width;
        canvas.height = image.height;
        const pixels2DContext = createCanvasContext(canvas);
        if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            bufferToTensorOptions.height = height;
            bufferToTensorOptions.width = width;
            return bufferToTensor(data, bufferToTensorOptions);
        } else {
            throw new Error('Can not access image data');
        }
    } else if (isString) {
        return new Promise((resolve, reject)=>{
            const canvas = createCanvas();
            const context = createCanvasContext(canvas);
            if (!image || !context) {
                return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = 'Anonymous';
            newImage.src = image;
            newImage.onload = ()=>{
                canvas.width = newImage.width;
                canvas.height = newImage.height;
                context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
                const img = context.getImageData(0, 0, canvas.width, canvas.height);
                bufferToTensorOptions.height = canvas.height;
                bufferToTensorOptions.width = canvas.width;
                resolve(bufferToTensor(img.data, bufferToTensorOptions));
            };
        });
    } else {
        throw new Error('Input data provided is not supported - aborted tensor creation');
    }
    if (data !== undefined) {
        return bufferToTensor(data, bufferToTensorOptions);
    } else {
        throw new Error('Input data provided is not supported - aborted tensor creation');
    }
};
const tensorFromTexture = (texture, options)=>{
    const { width, height, download, dispose } = options;
    // Always assume RGBAF32. TODO: support different texture format
    const dims = [
        1,
        height,
        width,
        4
    ];
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
        location: 'texture',
        type: 'float32',
        texture,
        dims,
        download,
        dispose
    });
};
const tensorFromGpuBuffer = (gpuBuffer, options)=>{
    const { dataType, dims, download, dispose } = options;
    return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
        location: 'gpu-buffer',
        type: dataType ?? 'float32',
        gpuBuffer,
        dims,
        download,
        dispose
    });
};
const tensorFromPinnedBuffer = (type, buffer, dims)=>new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
        location: 'cpu-pinned',
        type,
        data: buffer,
        dims: dims ?? [
            buffer.length
        ]
    }); //# sourceMappingURL=tensor-factory-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
// a runtime map that maps type string to TypedArray constructor. Should match Tensor.DataTypeMap.
__turbopack_context__.s([
    "NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP",
    ()=>NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP,
    "NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP",
    ()=>NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP,
    "checkTypedArray",
    ()=>checkTypedArray
]);
const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = new Map([
    [
        'float32',
        Float32Array
    ],
    [
        'uint8',
        Uint8Array
    ],
    [
        'int8',
        Int8Array
    ],
    [
        'uint16',
        Uint16Array
    ],
    [
        'int16',
        Int16Array
    ],
    [
        'int32',
        Int32Array
    ],
    [
        'bool',
        Uint8Array
    ],
    [
        'float64',
        Float64Array
    ],
    [
        'uint32',
        Uint32Array
    ]
]);
const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = new Map([
    [
        Float32Array,
        'float32'
    ],
    [
        Uint8Array,
        'uint8'
    ],
    [
        Int8Array,
        'int8'
    ],
    [
        Uint16Array,
        'uint16'
    ],
    [
        Int16Array,
        'int16'
    ],
    [
        Int32Array,
        'int32'
    ],
    [
        Float64Array,
        'float64'
    ],
    [
        Uint32Array,
        'uint32'
    ]
]);
// the following code allows delaying execution of BigInt/Float16Array checking. This allows lazy initialization for
// NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP and NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP, which allows BigInt/Float16Array
// polyfill if available.
let isTypedArrayChecked = false;
const checkTypedArray = ()=>{
    if (!isTypedArrayChecked) {
        isTypedArrayChecked = true;
        const isBigInt64ArrayAvailable = typeof BigInt64Array !== 'undefined' && BigInt64Array.from;
        const isBigUint64ArrayAvailable = typeof BigUint64Array !== 'undefined' && BigUint64Array.from;
        const isFloat16ArrayAvailable = typeof Float16Array !== 'undefined' && Float16Array.from;
        if (isBigInt64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('int64', BigInt64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, 'int64');
        }
        if (isBigUint64ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('uint64', BigUint64Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, 'uint64');
        }
        if (isFloat16ArrayAvailable) {
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Float16Array);
            NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(Float16Array, 'float16');
        } else {
            // if Float16Array is not available, use 'Uint16Array' to store the data.
            NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set('float16', Uint16Array);
        }
    }
}; //# sourceMappingURL=tensor-impl-type-mapping.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "calculateSize",
    ()=>calculateSize,
    "tensorReshape",
    ()=>tensorReshape
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)");
;
const calculateSize = (dims)=>{
    let size = 1;
    for(let i = 0; i < dims.length; i++){
        const dim = dims[i];
        if (typeof dim !== 'number' || !Number.isSafeInteger(dim)) {
            throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
        }
        if (dim < 0) {
            throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
        }
        size *= dim;
    }
    return size;
};
const tensorReshape = (tensor, dims)=>{
    switch(tensor.location){
        case 'cpu':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"](tensor.type, tensor.data, dims);
        case 'cpu-pinned':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
                location: 'cpu-pinned',
                data: tensor.data,
                type: tensor.type,
                dims
            });
        case 'texture':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
                location: 'texture',
                texture: tensor.texture,
                type: tensor.type,
                dims
            });
        case 'gpu-buffer':
            return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]({
                location: 'gpu-buffer',
                gpuBuffer: tensor.gpuBuffer,
                type: tensor.type,
                dims
            });
        default:
            throw new Error(`tensorReshape: tensor location ${tensor.location} is not supported`);
    }
}; //# sourceMappingURL=tensor-utils-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "Tensor",
    ()=>Tensor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-conversion-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-factory-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-impl-type-mapping.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$utils$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-utils-impl.js [app-ssr] (ecmascript)");
;
;
;
;
class Tensor {
    /**
     * implementation.
     */ constructor(arg0, arg1, arg2){
        // perform one-time check for BigInt/Float16Array support
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["checkTypedArray"])();
        let type;
        let dims;
        if (typeof arg0 === 'object' && 'location' in arg0) {
            //
            // constructing tensor from specific location
            //
            this.dataLocation = arg0.location;
            type = arg0.type;
            dims = arg0.dims;
            switch(arg0.location){
                case 'cpu-pinned':
                    {
                        const expectedTypedArrayConstructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP"].get(type);
                        if (!expectedTypedArrayConstructor) {
                            throw new TypeError(`unsupported type "${type}" to create tensor from pinned buffer`);
                        }
                        if (!(arg0.data instanceof expectedTypedArrayConstructor)) {
                            throw new TypeError(`buffer should be of type ${expectedTypedArrayConstructor.name}`);
                        }
                        this.cpuData = arg0.data;
                        break;
                    }
                case 'texture':
                    {
                        if (type !== 'float32') {
                            throw new TypeError(`unsupported type "${type}" to create tensor from texture`);
                        }
                        this.gpuTextureData = arg0.texture;
                        this.downloader = arg0.download;
                        this.disposer = arg0.dispose;
                        break;
                    }
                case 'gpu-buffer':
                    {
                        if (type !== 'float32' && type !== 'float16' && type !== 'int32' && type !== 'int64' && type !== 'uint32' && type !== 'uint8' && type !== 'bool') {
                            throw new TypeError(`unsupported type "${type}" to create tensor from gpu buffer`);
                        }
                        this.gpuBufferData = arg0.gpuBuffer;
                        this.downloader = arg0.download;
                        this.disposer = arg0.dispose;
                        break;
                    }
                default:
                    throw new Error(`Tensor constructor: unsupported location '${this.dataLocation}'`);
            }
        } else {
            //
            // constructing tensor of location 'cpu'
            //
            let data;
            let maybeDims;
            // check whether arg0 is type or data
            if (typeof arg0 === 'string') {
                //
                // Override: constructor(type, data, ...)
                //
                type = arg0;
                maybeDims = arg2;
                if (arg0 === 'string') {
                    // string tensor
                    if (!Array.isArray(arg1)) {
                        throw new TypeError('A string tensor\'s data must be a string array.');
                    }
                    // we don't check whether every element in the array is string; this is too slow. we assume it's correct and
                    // error will be populated at inference
                    data = arg1;
                } else {
                    // numeric tensor
                    const typedArrayConstructor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP"].get(arg0);
                    if (typedArrayConstructor === undefined) {
                        throw new TypeError(`Unsupported tensor type: ${arg0}.`);
                    }
                    if (Array.isArray(arg1)) {
                        if (arg0 === 'float16' && typedArrayConstructor === Uint16Array) {
                            // When no Float16Array polyfill is used, we cannot create 'float16' tensor from number array.
                            //
                            // Throw error here because when user try to use number array as data,
                            // e.g. new Tensor('float16', [1, 2, 3, 4], dims)), it will actually call
                            // Uint16Array.from(arg1) which generates wrong data.
                            throw new TypeError('Creating a float16 tensor from number array is not supported. Please use Uint16Array as data.');
                        } else if (arg0 === 'uint64' || arg0 === 'int64') {
                            // use 'as any' here because:
                            // 1. TypeScript's check on type of 'Array.isArray()' does not work with readonly arrays.
                            // see https://github.com/microsoft/TypeScript/issues/17002
                            // 2. TypeScript's check on union type of '(BigInt64ArrayConstructor|BigUint64ArrayConstructor).from()'
                            // does not accept parameter mapFn.
                            // 3. parameters of 'SupportedTypedArrayConstructors.from()' does not match the requirement of the union
                            // type.
                            // assume 'arg1' is of type "readonly number[]|readonly bigint[]" here.
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            data = typedArrayConstructor.from(arg1, BigInt);
                        } else {
                            // assume 'arg1' is of type "readonly number[]" here.
                            // eslint-disable-next-line @typescript-eslint/no-explicit-any
                            data = typedArrayConstructor.from(arg1);
                        }
                    } else if (arg1 instanceof typedArrayConstructor) {
                        data = arg1;
                    } else {
                        throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
                    }
                }
            } else {
                //
                // Override: constructor(data, ...)
                //
                maybeDims = arg1;
                if (Array.isArray(arg0)) {
                    // only boolean[] and string[] is supported
                    if (arg0.length === 0) {
                        throw new TypeError('Tensor type cannot be inferred from an empty array.');
                    }
                    const firstElementType = typeof arg0[0];
                    if (firstElementType === 'string') {
                        type = 'string';
                        data = arg0;
                    } else if (firstElementType === 'boolean') {
                        type = 'bool';
                        // 'arg0' is of type 'boolean[]'. Uint8Array.from(boolean[]) actually works, but typescript thinks this is
                        // wrong type. We use 'as any' to make it happy.
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        data = Uint8Array.from(arg0);
                    } else {
                        throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
                    }
                } else {
                    // get tensor type from TypedArray
                    const mappedType = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2d$type$2d$mapping$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP"].get(arg0.constructor);
                    if (mappedType === undefined) {
                        throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
                    }
                    type = mappedType;
                    data = arg0;
                }
            }
            // type and data is processed, now processing dims
            if (maybeDims === undefined) {
                // assume 1-D tensor if dims omitted
                maybeDims = [
                    data.length
                ];
            } else if (!Array.isArray(maybeDims)) {
                throw new TypeError('A tensor\'s dims must be a number array');
            }
            dims = maybeDims;
            this.cpuData = data;
            this.dataLocation = 'cpu';
        }
        // perform check on dims
        const size = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$utils$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["calculateSize"])(dims);
        // if data is on CPU, check whether data length matches tensor size
        if (this.cpuData && size !== this.cpuData.length) {
            throw new Error(`Tensor's size(${size}) does not match data length(${this.cpuData.length}).`);
        }
        this.type = type;
        this.dims = dims;
        this.size = size;
    }
    // #endregion
    // #region factory
    static async fromImage(image, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromImage"])(image, options);
    }
    static fromTexture(texture, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromTexture"])(texture, options);
    }
    static fromGpuBuffer(gpuBuffer, options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromGpuBuffer"])(gpuBuffer, options);
    }
    static fromPinnedBuffer(type, buffer, dims) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorFromPinnedBuffer"])(type, buffer, dims);
    }
    // #endregion
    // #region conversions
    toDataURL(options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorToDataURL"])(this, options);
    }
    toImageData(options) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorToImageData"])(this, options);
    }
    // #endregion
    // #region properties
    get data() {
        this.ensureValid();
        if (!this.cpuData) {
            throw new Error('The data is not on CPU. Use `getData()` to download GPU data to CPU, ' + 'or use `texture` or `gpuBuffer` property to access the GPU data directly.');
        }
        return this.cpuData;
    }
    get location() {
        return this.dataLocation;
    }
    get texture() {
        this.ensureValid();
        if (!this.gpuTextureData) {
            throw new Error('The data is not stored as a WebGL texture.');
        }
        return this.gpuTextureData;
    }
    get gpuBuffer() {
        this.ensureValid();
        if (!this.gpuBufferData) {
            throw new Error('The data is not stored as a WebGPU buffer.');
        }
        return this.gpuBufferData;
    }
    // #endregion
    // #region methods
    async getData(releaseData) {
        this.ensureValid();
        switch(this.dataLocation){
            case 'cpu':
            case 'cpu-pinned':
                return this.data;
            case 'texture':
            case 'gpu-buffer':
                {
                    if (!this.downloader) {
                        throw new Error('The current tensor is not created with a specified data downloader.');
                    }
                    if (this.isDownloading) {
                        throw new Error('The current tensor is being downloaded.');
                    }
                    try {
                        this.isDownloading = true;
                        const data = await this.downloader();
                        this.downloader = undefined;
                        this.dataLocation = 'cpu';
                        this.cpuData = data;
                        if (releaseData && this.disposer) {
                            this.disposer();
                            this.disposer = undefined;
                        }
                        return data;
                    } finally{
                        this.isDownloading = false;
                    }
                }
            default:
                throw new Error(`cannot get data from location: ${this.dataLocation}`);
        }
    }
    dispose() {
        if (this.isDownloading) {
            throw new Error('The current tensor is being downloaded.');
        }
        if (this.disposer) {
            this.disposer();
            this.disposer = undefined;
        }
        this.cpuData = undefined;
        this.gpuTextureData = undefined;
        this.gpuBufferData = undefined;
        this.downloader = undefined;
        this.isDownloading = undefined;
        this.dataLocation = 'none';
    }
    // #endregion
    // #region tensor utilities
    ensureValid() {
        if (this.dataLocation === 'none') {
            throw new Error('The tensor is disposed.');
        }
    }
    reshape(dims) {
        this.ensureValid();
        if (this.downloader || this.disposer) {
            throw new Error('Cannot reshape a tensor that owns GPU resource.');
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$utils$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tensorReshape"])(this, dims);
    }
} //# sourceMappingURL=tensor-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "Tensor",
    ()=>Tensor
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-impl.js [app-ssr] (ecmascript)");
;
const Tensor = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]; //# sourceMappingURL=tensor.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "TRACE",
    ()=>TRACE,
    "TRACE_FUNC_BEGIN",
    ()=>TRACE_FUNC_BEGIN,
    "TRACE_FUNC_END",
    ()=>TRACE_FUNC_END
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/env-impl.js [app-ssr] (ecmascript)");
;
const TRACE = (deviceType, label)=>{
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace === 'undefined' ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace : !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace) {
        return;
    }
    // eslint-disable-next-line no-console
    console.timeStamp(`${deviceType}::ORT::${label}`);
};
const TRACE_FUNC = (msg, extraMsg)=>{
    const stack = new Error().stack?.split(/\r\n|\r|\n/g) || [];
    let hasTraceFunc = false;
    for(let i = 0; i < stack.length; i++){
        if (hasTraceFunc && !stack[i].includes('TRACE_FUNC')) {
            let label = `FUNC_${msg}::${stack[i].trim().split(' ')[1]}`;
            if (extraMsg) {
                label += `::${extraMsg}`;
            }
            TRACE('CPU', label);
            return;
        }
        if (stack[i].includes('TRACE_FUNC')) {
            hasTraceFunc = true;
        }
    }
};
const TRACE_FUNC_BEGIN = (extraMsg)=>{
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace === 'undefined' ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace : !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace) {
        return;
    }
    TRACE_FUNC('BEGIN', extraMsg);
};
const TRACE_FUNC_END = (extraMsg)=>{
    if (typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace === 'undefined' ? !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace : !__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].trace) {
        return;
    }
    TRACE_FUNC('END', extraMsg);
}; //# sourceMappingURL=trace.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "InferenceSession",
    ()=>InferenceSession
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
;
;
;
class InferenceSession {
    constructor(handler){
        this.handler = handler;
    }
    async run(feeds, arg1, arg2) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"] || Array.isArray(feeds)) {
            throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                throw new TypeError('\'fetches\' cannot be a Tensor');
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError('\'fetches\' cannot be an empty array.');
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1){
                    if (typeof name !== 'string') {
                        throw new TypeError('\'fetches\' must be a string array or an object.');
                    }
                    if (this.outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'options\' must be an object.');
                }
            } else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of this.outputNames){
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    } else if (typeof arg2 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                } else {
                    options = arg1;
                }
            }
        } else if (typeof arg1 !== 'undefined') {
            throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        }
        // check if all inputs are in feed
        for (const name of this.inputNames){
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of this.outputNames){
                fetches[name] = null;
            }
        }
        // feeds, fetches and options are prepared
        const results = await this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for(const key in results){
            if (Object.hasOwnProperty.call(results, key)) {
                const result = results[key];
                if (result instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                    returnValue[key] = result;
                } else {
                    returnValue[key] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"](result.type, result.data, result.dims);
                }
            }
        }
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])();
        return returnValue;
    }
    async release() {
        return this.handler.dispose();
    }
    static async create(arg0, arg1, arg2, arg3) {
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
        // either load from a file or buffer
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === 'string') {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        } else if (arg0 instanceof Uint8Array) {
            filePathOrUint8Array = arg0;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== 'undefined' && arg0 instanceof SharedArrayBuffer) {
            const buffer = arg0;
            let byteOffset = 0;
            let byteLength = arg0.byteLength;
            if (typeof arg1 === 'object' && arg1 !== null) {
                options = arg1;
            } else if (typeof arg1 === 'number') {
                byteOffset = arg1;
                if (!Number.isSafeInteger(byteOffset)) {
                    throw new RangeError('\'byteOffset\' must be an integer.');
                }
                if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
                    throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
                }
                byteLength = arg0.byteLength - byteOffset;
                if (typeof arg2 === 'number') {
                    byteLength = arg2;
                    if (!Number.isSafeInteger(byteLength)) {
                        throw new RangeError('\'byteLength\' must be an integer.');
                    }
                    if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                        throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
                    }
                    if (typeof arg3 === 'object' && arg3 !== null) {
                        options = arg3;
                    } else if (typeof arg3 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'byteLength\' must be a number.');
                }
            } else if (typeof arg1 !== 'undefined') {
                throw new TypeError('\'options\' must be an object.');
            }
            filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
            throw new TypeError('Unexpected argument[0]: must be \'path\' or \'buffer\'.');
        }
        // resolve backend, update session options with validated EPs, and create session handler
        const [backend, optionsWithValidatedEPs] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolveBackendAndExecutionProviders"])(options);
        const handler = await backend.createInferenceSessionHandler(filePathOrUint8Array, optionsWithValidatedEPs);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])();
        return new InferenceSession(handler);
    }
    startProfiling() {
        this.handler.startProfiling();
    }
    endProfiling() {
        this.handler.endProfiling();
    }
    get inputNames() {
        return this.handler.inputNames;
    }
    get outputNames() {
        return this.handler.outputNames;
    }
} //# sourceMappingURL=inference-session-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/inference-session.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "InferenceSession",
    ()=>InferenceSession
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/inference-session-impl.js [app-ssr] (ecmascript)");
;
const InferenceSession = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InferenceSession"]; //# sourceMappingURL=inference-session.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([]);
;
 //# sourceMappingURL=tensor-conversion.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/tensor-factory.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([]);
;
 //# sourceMappingURL=tensor-factory.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/onnx-model.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([]);
;
 //# sourceMappingURL=onnx-model.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/onnx-value.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([]);
;
 //# sourceMappingURL=onnx-value.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/training-session-impl.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "TrainingSession",
    ()=>TrainingSession
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
;
;
const noBackendErrMsg = 'Training backend could not be resolved. ' + 'Make sure you\'re using the correct configuration & WebAssembly files.';
class TrainingSession {
    constructor(handler, hasOptimizerModel, hasEvalModel){
        this.handler = handler;
        this.hasOptimizerModel = hasOptimizerModel;
        this.hasEvalModel = hasEvalModel;
    }
    get trainingInputNames() {
        return this.handler.inputNames;
    }
    get trainingOutputNames() {
        return this.handler.outputNames;
    }
    get evalInputNames() {
        if (this.hasEvalModel) {
            return this.handler.evalInputNames;
        } else {
            throw new Error('This training session has no evalModel loaded.');
        }
    }
    get evalOutputNames() {
        if (this.hasEvalModel) {
            return this.handler.evalOutputNames;
        } else {
            throw new Error('This training session has no evalModel loaded.');
        }
    }
    static async create(trainingOptions, sessionOptions) {
        const evalModel = trainingOptions.evalModel || '';
        const optimizerModel = trainingOptions.optimizerModel || '';
        const options = sessionOptions || {};
        // resolve backend, update session options with validated EPs, and create session handler
        const [backend, optionsWithValidatedEPs] = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["resolveBackendAndExecutionProviders"])(options);
        if (backend.createTrainingSessionHandler) {
            const handler = await backend.createTrainingSessionHandler(trainingOptions.checkpointState, trainingOptions.trainModel, evalModel, optimizerModel, optionsWithValidatedEPs);
            return new TrainingSession(handler, !!trainingOptions.optimizerModel, !!trainingOptions.evalModel);
        } else {
            throw new Error(noBackendErrMsg);
        }
    }
    /**
     * Helper function for runTrainStep and future runStep methods that handles the type-narrowing conversion from
     * the given parameters to SessionHandler.FetchesType and RunOptions.
     *
     * @param inputNames the feeds object is checked that they contain all input names in the provided list of input
     * names.
     * @param outputNames the fetches object is checked that their keys match up with valid names in the list of output
     * names.
     * @param feeds the required input
     * @param arg1 narrowed & converted into the SessionHandler.FetchesType or RunOptions object
     * @param arg2 optional RunOptions object.
     * @returns
     */ typeNarrowingForRunStep(inputNames, outputNames, feeds, arg1, arg2) {
        const fetches = {};
        let options = {};
        // check inputs
        if (typeof feeds !== 'object' || feeds === null || feeds instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"] || Array.isArray(feeds)) {
            throw new TypeError('\'feeds\' must be an object that use input names as keys and OnnxValue as corresponding values.');
        }
        let isFetchesEmpty = true;
        // determine which override is being used
        if (typeof arg1 === 'object') {
            if (arg1 === null) {
                throw new TypeError('Unexpected argument[1]: cannot be null.');
            }
            if (arg1 instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                throw new TypeError('\'fetches\' cannot be a Tensor');
            }
            if (Array.isArray(arg1)) {
                if (arg1.length === 0) {
                    throw new TypeError('\'fetches\' cannot be an empty array.');
                }
                isFetchesEmpty = false;
                // output names
                for (const name of arg1){
                    if (typeof name !== 'string') {
                        throw new TypeError('\'fetches\' must be a string array or an object.');
                    }
                    if (outputNames.indexOf(name) === -1) {
                        throw new RangeError(`'fetches' contains invalid output name: ${name}.`);
                    }
                    fetches[name] = null;
                }
                if (typeof arg2 === 'object' && arg2 !== null) {
                    options = arg2;
                } else if (typeof arg2 !== 'undefined') {
                    throw new TypeError('\'options\' must be an object.');
                }
            } else {
                // decide whether arg1 is fetches or options
                // if any output name is present and its value is valid OnnxValue, we consider it fetches
                let isFetches = false;
                const arg1Keys = Object.getOwnPropertyNames(arg1);
                for (const name of outputNames){
                    if (arg1Keys.indexOf(name) !== -1) {
                        const v = arg1[name];
                        if (v === null || v instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                            isFetches = true;
                            isFetchesEmpty = false;
                            fetches[name] = v;
                        }
                    }
                }
                if (isFetches) {
                    if (typeof arg2 === 'object' && arg2 !== null) {
                        options = arg2;
                    } else if (typeof arg2 !== 'undefined') {
                        throw new TypeError('\'options\' must be an object.');
                    }
                } else {
                    options = arg1;
                }
            }
        } else if (typeof arg1 !== 'undefined') {
            throw new TypeError('Unexpected argument[1]: must be \'fetches\' or \'options\'.');
        }
        // check if all inputs are in feed
        for (const name of inputNames){
            if (typeof feeds[name] === 'undefined') {
                throw new Error(`input '${name}' is missing in 'feeds'.`);
            }
        }
        // if no fetches is specified, we use the full output names list
        if (isFetchesEmpty) {
            for (const name of outputNames){
                fetches[name] = null;
            }
        }
        return [
            fetches,
            options
        ];
    }
    /**
     * Helper method for runTrainStep and any other runStep methods. Takes the ReturnType result from the SessionHandler
     * and changes it into a map of Tensors.
     *
     * @param results
     * @returns
     */ convertHandlerReturnTypeToMapOfTensors(results) {
        const returnValue = {};
        for(const key in results){
            if (Object.hasOwnProperty.call(results, key)) {
                const result = results[key];
                if (result instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"]) {
                    returnValue[key] = result;
                } else {
                    returnValue[key] = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"](result.type, result.data, result.dims);
                }
            }
        }
        return returnValue;
    }
    async lazyResetGrad() {
        await this.handler.lazyResetGrad();
    }
    async runTrainStep(feeds, arg1, arg2) {
        const [fetches, options] = this.typeNarrowingForRunStep(this.trainingInputNames, this.trainingOutputNames, feeds, arg1, arg2);
        const results = await this.handler.runTrainStep(feeds, fetches, options);
        return this.convertHandlerReturnTypeToMapOfTensors(results);
    }
    async runOptimizerStep(options) {
        if (this.hasOptimizerModel) {
            await this.handler.runOptimizerStep(options || {});
        } else {
            throw new Error('This TrainingSession has no OptimizerModel loaded.');
        }
    }
    async runEvalStep(feeds, arg1, arg2) {
        if (this.hasEvalModel) {
            const [fetches, options] = this.typeNarrowingForRunStep(this.evalInputNames, this.evalOutputNames, feeds, arg1, arg2);
            const results = await this.handler.runEvalStep(feeds, fetches, options);
            return this.convertHandlerReturnTypeToMapOfTensors(results);
        } else {
            throw new Error('This TrainingSession has no EvalModel loaded.');
        }
    }
    async getParametersSize(trainableOnly = true) {
        return this.handler.getParametersSize(trainableOnly);
    }
    async loadParametersBuffer(array, trainableOnly = true) {
        const paramsSize = await this.getParametersSize(trainableOnly);
        // checking that the size of the Uint8Array is equivalent to the byte length of a Float32Array of the number
        // of parameters
        if (array.length !== 4 * paramsSize) {
            throw new Error('Size of the buffer passed into loadParametersBuffer must match the number of parameters in ' + 'the model. Please use getParametersSize method to check.');
        }
        return this.handler.loadParametersBuffer(array, trainableOnly);
    }
    async getContiguousParameters(trainableOnly = true) {
        return this.handler.getContiguousParameters(trainableOnly);
    }
    async release() {
        return this.handler.dispose();
    }
} //# sourceMappingURL=training-session-impl.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/training-session.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
__turbopack_context__.s([
    "TrainingSession",
    ()=>TrainingSession
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$training$2d$session$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/training-session-impl.js [app-ssr] (ecmascript)");
;
const TrainingSession = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$training$2d$session$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TrainingSession"]; //# sourceMappingURL=training-session.js.map
}),
"[project]/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.
/**
 * # ONNX Runtime JavaScript API
 *
 * ONNX Runtime JavaScript API is a unified API for all JavaScript usages, including the following NPM packages:
 *
 * - [onnxruntime-node](https://www.npmjs.com/package/onnxruntime-node)
 * - [onnxruntime-web](https://www.npmjs.com/package/onnxruntime-web)
 * - [onnxruntime-react-native](https://www.npmjs.com/package/onnxruntime-react-native)
 *
 * See also:
 * - [Get Started](https://onnxruntime.ai/docs/get-started/with-javascript/)
 * - [Inference examples](https://github.com/microsoft/onnxruntime-inference-examples/tree/main/js)
 *
 * @packageDocumentation
 */ __turbopack_context__.s([]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/inference-session.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/onnx-model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/onnx-value.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$training$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/training-session.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
;
;
;
;
;
;
;
;
;
;
}),
"[project]/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "registerBackend",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2d$impl$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend-impl.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InferenceSession",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InferenceSession"],
    "TRACE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE"],
    "TRACE_FUNC_BEGIN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"],
    "TRACE_FUNC_END",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"],
    "Tensor",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"],
    "TrainingSession",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$training$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TrainingSession"],
    "env",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"],
    "registerBackend",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$inference$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/inference-session.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$conversion$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-conversion.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2d$factory$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor-factory.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/onnx-model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$onnx$2d$value$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/onnx-value.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$training$2d$session$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/training-session.js [app-ssr] (ecmascript)");
}),
"[project]/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <locals>", ((__turbopack_context__) => {
"use strict";

/*!
 * ONNX Runtime Web v1.19.0
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */ __turbopack_context__.s([
    "default",
    ()=>Ur
]);
var __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__ = __turbopack_context__.i("[externals]/module [external] (module, cjs)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/env.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/tensor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/trace.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/backend.js [app-ssr] (ecmascript)");
const __TURBOPACK__import$2e$meta__ = {
    get url () {
        return `file://${__turbopack_context__.P("node_modules/onnxruntime-web/dist/ort.node.min.mjs")}`;
    }
};
;
const require = (0, __TURBOPACK__imported__module__$5b$externals$5d2f$module__$5b$external$5d$__$28$module$2c$__cjs$29$__["createRequire"])(__TURBOPACK__import$2e$meta__.url);
var oe = Object.defineProperty;
var ft = Object.getOwnPropertyDescriptor;
var dt = Object.getOwnPropertyNames;
var pt = Object.prototype.hasOwnProperty;
var se = ((e)=>("TURBOPACK compile-time value", "function") < "u" ? require : typeof Proxy < "u" ? new Proxy(e, {
        get: (t, n)=>(("TURBOPACK compile-time value", "function") < "u" ? require : t)[n]
    }) : e)(function(e) {
    if (("TURBOPACK compile-time value", "function") < "u") return require.apply(this, arguments);
    throw Error('Dynamic require of "' + e + '" is not supported');
});
var P = (e, t)=>()=>(e && (t = e(e = 0)), t);
var mt = (e, t)=>{
    for(var n in t)oe(e, n, {
        get: t[n],
        enumerable: !0
    });
}, gt = (e, t, n, s)=>{
    if (t && typeof t == "object" || typeof t == "function") for (let r of dt(t))!pt.call(e, r) && r !== n && oe(e, r, {
        get: ()=>t[r],
        enumerable: !(s = ft(t, r)) || s.enumerable
    });
    return e;
};
var yt = (e)=>gt(oe({}, "__esModule", {
        value: !0
    }), e);
var k, K = P(()=>{
    "use strict";
    k = !!(typeof process < "u" && process.versions && process.versions.node);
});
var D, bt, wt, ht, St, Et, Ot, ve, Q = P(()=>{
    "use strict";
    K();
    D = k ? void 0 : __TURBOPACK__import$2e$meta__.url ?? (typeof document < "u" ? document.currentScript?.src : typeof self < "u" ? self.location?.href : void 0), bt = k || typeof location > "u" ? void 0 : location.origin, wt = (e, t)=>{
        try {
            let n = t ?? D;
            return (n ? new URL(e, n) : new URL(e)).origin === bt;
        } catch  {
            return !1;
        }
    }, ht = (e, t)=>{
        let n = t ?? D;
        try {
            return (n ? new URL(e, n) : new URL(e)).href;
        } catch  {
            return;
        }
    }, St = (e, t)=>`${t ?? "./"}${e}`, Et = async (e)=>{
        let n = await (await fetch(e, {
            credentials: "same-origin"
        })).blob();
        return URL.createObjectURL(n);
    }, Ot = async (e)=>(await import(/*webpackIgnore:true*/ e)).default, ve = async (e, t, n)=>{
        {
            let s = "ort-wasm-simd-threaded.mjs", r = e ?? ht(s, t), a = !k && n && r && !wt(r, t), o = a ? await Et(r) : r ?? St(s, t);
            return [
                a ? o : void 0,
                await Ot(o)
            ];
        }
    };
});
var ae, ie, Z, Ae, vt, At, Ie, S, W = P(()=>{
    "use strict";
    Q();
    ie = !1, Z = !1, Ae = !1, vt = ()=>{
        if (typeof SharedArrayBuffer > "u") return !1;
        try {
            return typeof MessageChannel < "u" && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                2,
                1,
                0,
                5,
                4,
                1,
                3,
                1,
                1,
                10,
                11,
                1,
                9,
                0,
                65,
                0,
                254,
                16,
                2,
                0,
                26,
                11
            ]));
        } catch  {
            return !1;
        }
    }, At = ()=>{
        try {
            return WebAssembly.validate(new Uint8Array([
                0,
                97,
                115,
                109,
                1,
                0,
                0,
                0,
                1,
                4,
                1,
                96,
                0,
                0,
                3,
                2,
                1,
                0,
                10,
                30,
                1,
                28,
                0,
                65,
                0,
                253,
                15,
                253,
                12,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                0,
                253,
                186,
                1,
                26,
                11
            ]));
        } catch  {
            return !1;
        }
    }, Ie = async (e)=>{
        if (ie) return Promise.resolve();
        if (Z) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
        if (Ae) throw new Error("previous call to 'initializeWebAssembly()' failed.");
        Z = !0;
        let t = e.initTimeout, n = e.numThreads;
        if (!At()) throw new Error("WebAssembly SIMD is not supported in the current environment.");
        let s = vt();
        n > 1 && !s && (typeof self < "u" && !self.crossOriginIsolated && console.warn("env.wasm.numThreads is set to " + n + ", but this will not work unless you enable crossOriginIsolated mode. See https://web.dev/cross-origin-isolation-guide/ for more info."), console.warn("WebAssembly multi-threading is not supported in the current environment. Falling back to single-threading."), e.numThreads = n = 1);
        let r = e.wasmPaths, a = typeof r == "string" ? r : void 0, o = r?.mjs, u = o?.href ?? o, c = r?.wasm, d = c?.href ?? c, y = e.wasmBinary, [l, i] = await ve(u, a, n > 1), b = !1, f = [];
        if (t > 0 && f.push(new Promise((g)=>{
            setTimeout(()=>{
                b = !0, g();
            }, t);
        })), f.push(new Promise((g, O)=>{
            let T = {
                numThreads: n
            };
            y ? T.wasmBinary = y : (d || a) && (T.locateFile = (p, w)=>d ?? (a ?? w) + p), i(T).then((p)=>{
                Z = !1, ie = !0, ae = p, g(), l && URL.revokeObjectURL(l);
            }, (p)=>{
                Z = !1, Ae = !0, O(p);
            });
        })), await Promise.race(f), b) throw new Error(`WebAssembly backend initializing failed due to timeout: ${t}ms`);
    }, S = ()=>{
        if (ie && ae) return ae;
        throw new Error("WebAssembly is not initialized yet.");
    };
});
var E, G, h, ee = P(()=>{
    "use strict";
    W();
    E = (e, t)=>{
        let n = S(), s = n.lengthBytesUTF8(e) + 1, r = n._malloc(s);
        return n.stringToUTF8(e, r, s), t.push(r), r;
    }, G = (e, t, n, s)=>{
        if (typeof e == "object" && e !== null) {
            if (n.has(e)) throw new Error("Circular reference in options");
            n.add(e);
        }
        Object.entries(e).forEach(([r, a])=>{
            let o = t ? t + r : r;
            if (typeof a == "object") G(a, o + ".", n, s);
            else if (typeof a == "string" || typeof a == "number") s(o, a.toString());
            else if (typeof a == "boolean") s(o, a ? "1" : "0");
            else throw new Error(`Can't handle extra config type: ${typeof a}`);
        });
    }, h = (e)=>{
        let t = S(), n = t.stackSave();
        try {
            let s = t.stackAlloc(8);
            t._OrtGetLastError(s, s + 4);
            let r = t.HEAP32[s / 4], a = t.HEAPU32[s / 4 + 1], o = a ? t.UTF8ToString(a) : "";
            throw new Error(`${e} ERROR_CODE: ${r}, ERROR_MESSAGE: ${o}`);
        } finally{
            t.stackRestore(n);
        }
    };
});
var xe, Pe = P(()=>{
    "use strict";
    W();
    ee();
    xe = (e)=>{
        let t = S(), n = 0, s = [], r = e || {};
        try {
            if (e?.logSeverityLevel === void 0) r.logSeverityLevel = 2;
            else if (typeof e.logSeverityLevel != "number" || !Number.isInteger(e.logSeverityLevel) || e.logSeverityLevel < 0 || e.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${e.logSeverityLevel}`);
            if (e?.logVerbosityLevel === void 0) r.logVerbosityLevel = 0;
            else if (typeof e.logVerbosityLevel != "number" || !Number.isInteger(e.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${e.logVerbosityLevel}`);
            e?.terminate === void 0 && (r.terminate = !1);
            let a = 0;
            return e?.tag !== void 0 && (a = E(e.tag, s)), n = t._OrtCreateRunOptions(r.logSeverityLevel, r.logVerbosityLevel, !!r.terminate, a), n === 0 && h("Can't create run options."), e?.extra !== void 0 && G(e.extra, "", new WeakSet, (o, u)=>{
                let c = E(o, s), d = E(u, s);
                t._OrtAddRunConfigEntry(n, c, d) !== 0 && h(`Can't set a run config entry: ${o} - ${u}.`);
            }), [
                n,
                s
            ];
        } catch (a) {
            throw n !== 0 && t._OrtReleaseRunOptions(n), s.forEach((o)=>t._free(o)), a;
        }
    };
});
var It, xt, Pt, Lt, Le, Te = P(()=>{
    "use strict";
    W();
    ee();
    It = (e)=>{
        switch(e){
            case "disabled":
                return 0;
            case "basic":
                return 1;
            case "extended":
                return 2;
            case "all":
                return 99;
            default:
                throw new Error(`unsupported graph optimization level: ${e}`);
        }
    }, xt = (e)=>{
        switch(e){
            case "sequential":
                return 0;
            case "parallel":
                return 1;
            default:
                throw new Error(`unsupported execution mode: ${e}`);
        }
    }, Pt = (e)=>{
        e.extra || (e.extra = {}), e.extra.session || (e.extra.session = {});
        let t = e.extra.session;
        t.use_ort_model_bytes_directly || (t.use_ort_model_bytes_directly = "1"), e.executionProviders && e.executionProviders.some((n)=>(typeof n == "string" ? n : n.name) === "webgpu") && (e.enableMemPattern = !1);
    }, Lt = (e, t, n)=>{
        for (let s of t){
            let r = typeof s == "string" ? s : s.name;
            switch(r){
                case "webnn":
                    if (r = "WEBNN", typeof s != "string") {
                        let u = s?.deviceType;
                        if (u) {
                            let c = E("deviceType", n), d = E(u, n);
                            S()._OrtAddSessionConfigEntry(e, c, d) !== 0 && h(`Can't set a session config entry: 'deviceType' - ${u}.`);
                        }
                    }
                    break;
                case "webgpu":
                    if (r = "JS", typeof s != "string") {
                        let o = s;
                        if (o?.preferredLayout) {
                            if (o.preferredLayout !== "NCHW" && o.preferredLayout !== "NHWC") throw new Error(`preferredLayout must be either 'NCHW' or 'NHWC': ${o.preferredLayout}`);
                            let u = E("preferredLayout", n), c = E(o.preferredLayout, n);
                            S()._OrtAddSessionConfigEntry(e, u, c) !== 0 && h(`Can't set a session config entry: 'preferredLayout' - ${o.preferredLayout}.`);
                        }
                    }
                    break;
                case "wasm":
                case "cpu":
                    continue;
                default:
                    throw new Error(`not supported execution provider: ${r}`);
            }
            let a = E(r, n);
            S()._OrtAppendExecutionProvider(e, a) !== 0 && h(`Can't append execution provider: ${r}.`);
        }
    }, Le = (e)=>{
        let t = S(), n = 0, s = [], r = e || {};
        Pt(r);
        try {
            let a = It(r.graphOptimizationLevel ?? "all"), o = xt(r.executionMode ?? "sequential"), u = typeof r.logId == "string" ? E(r.logId, s) : 0, c = r.logSeverityLevel ?? 2;
            if (!Number.isInteger(c) || c < 0 || c > 4) throw new Error(`log serverity level is not valid: ${c}`);
            let d = r.logVerbosityLevel ?? 0;
            if (!Number.isInteger(d) || d < 0 || d > 4) throw new Error(`log verbosity level is not valid: ${d}`);
            let y = typeof r.optimizedModelFilePath == "string" ? E(r.optimizedModelFilePath, s) : 0;
            if (n = t._OrtCreateSessionOptions(a, !!r.enableCpuMemArena, !!r.enableMemPattern, o, !!r.enableProfiling, 0, u, c, d, y), n === 0 && h("Can't create session options."), r.executionProviders && Lt(n, r.executionProviders, s), r.enableGraphCapture !== void 0) {
                if (typeof r.enableGraphCapture != "boolean") throw new Error(`enableGraphCapture must be a boolean value: ${r.enableGraphCapture}`);
                let l = E("enableGraphCapture", s), i = E(r.enableGraphCapture.toString(), s);
                t._OrtAddSessionConfigEntry(n, l, i) !== 0 && h(`Can't set a session config entry: 'enableGraphCapture' - ${r.enableGraphCapture}.`);
            }
            if (r.freeDimensionOverrides) for (let [l, i] of Object.entries(r.freeDimensionOverrides)){
                if (typeof l != "string") throw new Error(`free dimension override name must be a string: ${l}`);
                if (typeof i != "number" || !Number.isInteger(i) || i < 0) throw new Error(`free dimension override value must be a non-negative integer: ${i}`);
                let b = E(l, s);
                t._OrtAddFreeDimensionOverride(n, b, i) !== 0 && h(`Can't set a free dimension override: ${l} - ${i}.`);
            }
            return r.extra !== void 0 && G(r.extra, "", new WeakSet, (l, i)=>{
                let b = E(l, s), f = E(i, s);
                t._OrtAddSessionConfigEntry(n, b, f) !== 0 && h(`Can't set a session config entry: ${l} - ${i}.`);
            }), [
                n,
                s
            ];
        } catch (a) {
            throw n !== 0 && t._OrtReleaseSessionOptions(n), s.forEach((o)=>t._free(o)), a;
        }
    };
});
var ue, Ce, ce, Be, ke, te, Ue, le = P(()=>{
    "use strict";
    ue = (e)=>{
        switch(e){
            case "int8":
                return 3;
            case "uint8":
                return 2;
            case "bool":
                return 9;
            case "int16":
                return 5;
            case "uint16":
                return 4;
            case "int32":
                return 6;
            case "uint32":
                return 12;
            case "float16":
                return 10;
            case "float32":
                return 1;
            case "float64":
                return 11;
            case "string":
                return 8;
            case "int64":
                return 7;
            case "uint64":
                return 13;
            default:
                throw new Error(`unsupported data type: ${e}`);
        }
    }, Ce = (e)=>{
        switch(e){
            case 3:
                return "int8";
            case 2:
                return "uint8";
            case 9:
                return "bool";
            case 5:
                return "int16";
            case 4:
                return "uint16";
            case 6:
                return "int32";
            case 12:
                return "uint32";
            case 10:
                return "float16";
            case 1:
                return "float32";
            case 11:
                return "float64";
            case 8:
                return "string";
            case 7:
                return "int64";
            case 13:
                return "uint64";
            default:
                throw new Error(`unsupported data type: ${e}`);
        }
    }, ce = (e)=>[
            void 0,
            4,
            1,
            1,
            2,
            2,
            4,
            8,
            void 0,
            1,
            2,
            8,
            4,
            8,
            void 0,
            void 0,
            void 0
        ][e], Be = (e)=>{
        switch(e){
            case "float16":
                return typeof Float16Array < "u" && Float16Array.from ? Float16Array : Uint16Array;
            case "float32":
                return Float32Array;
            case "uint8":
                return Uint8Array;
            case "int8":
                return Int8Array;
            case "uint16":
                return Uint16Array;
            case "int16":
                return Int16Array;
            case "int32":
                return Int32Array;
            case "bool":
                return Uint8Array;
            case "float64":
                return Float64Array;
            case "uint32":
                return Uint32Array;
            case "int64":
                return BigInt64Array;
            case "uint64":
                return BigUint64Array;
            default:
                throw new Error(`unsupported type: ${e}`);
        }
    }, ke = (e)=>{
        switch(e){
            case "verbose":
                return 0;
            case "info":
                return 1;
            case "warning":
                return 2;
            case "error":
                return 3;
            case "fatal":
                return 4;
            default:
                throw new Error(`unsupported logging level: ${e}`);
        }
    }, te = (e)=>e === "float32" || e === "float16" || e === "int32" || e === "int64" || e === "uint32" || e === "uint8" || e === "bool", Ue = (e)=>{
        switch(e){
            case "none":
                return 0;
            case "cpu":
                return 1;
            case "cpu-pinned":
                return 2;
            case "texture":
                return 3;
            case "gpu-buffer":
                return 4;
            default:
                throw new Error(`unsupported data location: ${e}`);
        }
    };
});
var q, fe = P(()=>{
    "use strict";
    K();
    q = async (e)=>{
        if (typeof e == "string") if (k) try {
            let { readFile: t } = se("node:fs/promises");
            return new Uint8Array(await t(e));
        } catch (t) {
            if (t.code === "ERR_FS_FILE_TOO_LARGE") {
                let { createReadStream: n } = se("node:fs"), s = n(e), r = [];
                for await (let a of s)r.push(a);
                return new Uint8Array(Buffer.concat(r));
            }
            throw t;
        }
        else {
            let t = await fetch(e);
            if (!t.ok) throw new Error(`failed to load external data file: ${e}`);
            let n = t.headers.get("Content-Length"), s = n ? parseInt(n, 10) : 0;
            if (s < 1073741824) return new Uint8Array(await t.arrayBuffer());
            {
                if (!t.body) throw new Error(`failed to load external data file: ${e}, no response body.`);
                let r = t.body.getReader(), a;
                try {
                    a = new ArrayBuffer(s);
                } catch (u) {
                    if (u instanceof RangeError) {
                        let c = Math.ceil(s / 65536);
                        a = new WebAssembly.Memory({
                            initial: c,
                            maximum: c
                        }).buffer;
                    } else throw u;
                }
                let o = 0;
                for(;;){
                    let { done: u, value: c } = await r.read();
                    if (u) break;
                    let d = c.byteLength;
                    new Uint8Array(a, o, d).set(c), o += d;
                }
                return new Uint8Array(a, 0, s);
            }
        }
        else return e instanceof Blob ? new Uint8Array(await e.arrayBuffer()) : e instanceof Uint8Array ? e : new Uint8Array(e);
    };
});
var Tt, De, Me, F, Ct, de, We, Fe, _e, Ne, Re, $e = P(()=>{
    "use strict";
    Pe();
    Te();
    le();
    W();
    ee();
    fe();
    Tt = (e, t)=>{
        S()._OrtInit(e, t) !== 0 && h("Can't initialize onnxruntime.");
    }, De = async (e)=>{
        Tt(e.wasm.numThreads, ke(e.logLevel));
    }, Me = async (e, t)=>{}, F = new Map, Ct = (e)=>{
        let t = S(), n = t.stackSave();
        try {
            let s = t.stackAlloc(8);
            return t._OrtGetInputOutputCount(e, s, s + 4) !== 0 && h("Can't get session input/output count."), [
                t.HEAP32[s / 4],
                t.HEAP32[s / 4 + 1]
            ];
        } finally{
            t.stackRestore(n);
        }
    }, de = (e)=>{
        let t = S(), n = t._malloc(e.byteLength);
        if (n === 0) throw new Error(`Can't create a session. failed to allocate a buffer of size ${e.byteLength}.`);
        return t.HEAPU8.set(e, n), [
            n,
            e.byteLength
        ];
    }, We = async (e, t)=>{
        let n, s, r = S();
        Array.isArray(e) ? [n, s] = e : e.buffer === r.HEAPU8.buffer ? [n, s] = [
            e.byteOffset,
            e.byteLength
        ] : [n, s] = de(e);
        let a = 0, o = 0, u = 0, c = [], d = [], y = [];
        try {
            if ([o, c] = Le(t), t?.externalData && r.mountExternalData) {
                let p = [];
                for (let w of t.externalData){
                    let A = typeof w == "string" ? w : w.path;
                    p.push(q(typeof w == "string" ? w : w.data).then((U)=>{
                        r.mountExternalData(A, U);
                    }));
                }
                await Promise.all(p);
            }
            for (let p of t?.executionProviders ?? [])if ((typeof p == "string" ? p : p.name) === "webnn") {
                if (r.currentContext) throw new Error("WebNN execution provider is already set.");
                if (typeof p != "string") {
                    let A = p, U = A?.context, N = A?.gpuDevice, V = A?.deviceType, R = A?.numThreads, J = A?.powerPreference;
                    U ? r.currentContext = U : N ? r.currentContext = await navigator.ml.createContext(N) : r.currentContext = await navigator.ml.createContext({
                        deviceType: V,
                        numThreads: R,
                        powerPreference: J
                    });
                } else r.currentContext = await navigator.ml.createContext();
                break;
            }
            a = await r._OrtCreateSession(n, s, o), a === 0 && h("Can't create a session."), r.currentContext && (r.currentContext = void 0);
            let [l, i] = Ct(a), b = !!t?.enableGraphCapture, f = [], g = [], O = [];
            for(let p = 0; p < l; p++){
                let w = r._OrtGetInputName(a, p);
                w === 0 && h("Can't get an input name."), d.push(w), f.push(r.UTF8ToString(w));
            }
            for(let p = 0; p < i; p++){
                let w = r._OrtGetOutputName(a, p);
                w === 0 && h("Can't get an output name."), y.push(w);
                let A = r.UTF8ToString(w);
                g.push(A);
            }
            let T = null;
            return F.set(a, [
                a,
                d,
                y,
                T,
                b,
                !1
            ]), [
                a,
                f,
                g
            ];
        } catch (l) {
            throw d.forEach((i)=>r._OrtFree(i)), y.forEach((i)=>r._OrtFree(i)), u !== 0 && r._OrtReleaseBinding(u), a !== 0 && r._OrtReleaseSession(a), l;
        } finally{
            r._free(n), o !== 0 && r._OrtReleaseSessionOptions(o), c.forEach((l)=>r._free(l)), r.unmountExternalData?.();
        }
    }, Fe = (e)=>{
        let t = S(), n = F.get(e);
        if (!n) throw new Error(`cannot release session. invalid session id: ${e}`);
        let [s, r, a, o, u] = n;
        o && (u && t._OrtClearBoundOutputs(o.handle), t._OrtReleaseBinding(o.handle)), t.jsepOnReleaseSession?.(e), r.forEach((c)=>t._OrtFree(c)), a.forEach((c)=>t._OrtFree(c)), t._OrtReleaseSession(s), F.delete(e);
    }, _e = (e, t, n, s, r, a = !1)=>{
        if (!e) {
            t.push(0);
            return;
        }
        let o = S(), u = e[0], c = e[1], d = e[3], y, l;
        if (u === "string" && d === "gpu-buffer") throw new Error("String tensor is not supported on GPU.");
        if (a && d !== "gpu-buffer") throw new Error(`External buffer must be provided for input/output index ${r} when enableGraphCapture is true.`);
        if (d === "gpu-buffer") {
            let f = e[2].gpuBuffer, g = ce(ue(u));
            l = c.reduce((T, p)=>T * p, 1) * g;
            let O = o.jsepRegisterBuffer;
            if (!O) throw new Error('Tensor location "gpu-buffer" is not supported without using WebGPU.');
            y = O(s, r, f, l);
        } else {
            let f = e[2];
            if (Array.isArray(f)) {
                l = 4 * f.length, y = o._malloc(l), n.push(y);
                let g = y / 4;
                for(let O = 0; O < f.length; O++){
                    if (typeof f[O] != "string") throw new TypeError(`tensor data at index ${O} is not a string`);
                    o.HEAPU32[g++] = E(f[O], n);
                }
            } else l = f.byteLength, y = o._malloc(l), n.push(y), o.HEAPU8.set(new Uint8Array(f.buffer, f.byteOffset, l), y);
        }
        let i = o.stackSave(), b = o.stackAlloc(4 * c.length);
        try {
            let f = b / 4;
            c.forEach((O)=>o.HEAP32[f++] = O);
            let g = o._OrtCreateTensor(ue(u), y, l, b, c.length, Ue(d));
            g === 0 && h(`Can't create tensor for input/output. session=${s}, index=${r}.`), t.push(g);
        } finally{
            o.stackRestore(i);
        }
    }, Ne = async (e, t, n, s, r, a)=>{
        let o = S(), u = F.get(e);
        if (!u) throw new Error(`cannot run inference. invalid session id: ${e}`);
        let c = u[0], d = u[1], y = u[2], l = u[3], i = u[4], b = u[5], f = t.length, g = s.length, O = 0, T = [], p = [], w = [], A = [], U = o.stackSave(), N = o.stackAlloc(f * 4), V = o.stackAlloc(f * 4), R = o.stackAlloc(g * 4), J = o.stackAlloc(g * 4);
        try {
            [O, T] = xe(a);
            for(let m = 0; m < f; m++)_e(n[m], p, A, e, t[m], i);
            for(let m = 0; m < g; m++)_e(r[m], w, A, e, f + s[m], i);
            let C = N / 4, at = V / 4, it = R / 4, ut = J / 4;
            for(let m = 0; m < f; m++)o.HEAPU32[C++] = p[m], o.HEAPU32[at++] = d[t[m]];
            for(let m = 0; m < g; m++)o.HEAPU32[it++] = w[m], o.HEAPU32[ut++] = y[s[m]];
            o.jsepOnRunStart?.(c);
            let ye;
            ye = await o._OrtRun(c, V, N, f, J, g, R, O), ye !== 0 && h("failed to call OrtRun().");
            let $ = [];
            for(let m = 0; m < g; m++){
                let H = o.HEAPU32[R / 4 + m];
                if (H === w[m]) {
                    $.push(r[m]);
                    continue;
                }
                let be = o.stackSave(), _ = o.stackAlloc(4 * 4), Y = !1, L, B = 0;
                try {
                    o._OrtGetTensorData(H, _, _ + 4, _ + 8, _ + 12) !== 0 && h(`Can't access output tensor data on index ${m}.`);
                    let X = _ / 4, we = o.HEAPU32[X++];
                    B = o.HEAPU32[X++];
                    let he = o.HEAPU32[X++], ct = o.HEAPU32[X++], j = [];
                    for(let I = 0; I < ct; I++)j.push(o.HEAPU32[he / 4 + I]);
                    o._OrtFree(he);
                    let z = j.reduce((I, x)=>I * x, 1);
                    L = Ce(we);
                    let Se = l?.outputPreferredLocations[s[m]];
                    if (L === "string") {
                        if (Se === "gpu-buffer") throw new Error("String tensor is not supported on GPU.");
                        let I = [], x = B / 4;
                        for(let M = 0; M < z; M++){
                            let Ee = o.HEAPU32[x++], lt = M === z - 1 ? void 0 : o.HEAPU32[x] - Ee;
                            I.push(o.UTF8ToString(Ee, lt));
                        }
                        $.push([
                            L,
                            j,
                            I,
                            "cpu"
                        ]);
                    } else if (Se === "gpu-buffer" && z > 0) {
                        let I = o.jsepGetBuffer;
                        if (!I) throw new Error('preferredLocation "gpu-buffer" is not supported without using WebGPU.');
                        let x = I(B), M = ce(we);
                        if (M === void 0 || !te(L)) throw new Error(`Unsupported data type: ${L}`);
                        Y = !0, $.push([
                            L,
                            j,
                            {
                                gpuBuffer: x,
                                download: o.jsepCreateDownloader(x, z * M, L),
                                dispose: ()=>{
                                    o._OrtReleaseTensor(H);
                                }
                            },
                            "gpu-buffer"
                        ]);
                    } else {
                        let I = Be(L), x = new I(z);
                        new Uint8Array(x.buffer, x.byteOffset, x.byteLength).set(o.HEAPU8.subarray(B, B + x.byteLength)), $.push([
                            L,
                            j,
                            x,
                            "cpu"
                        ]);
                    }
                } finally{
                    o.stackRestore(be), L === "string" && B && o._free(B), Y || o._OrtReleaseTensor(H);
                }
            }
            return l && !i && (o._OrtClearBoundOutputs(l.handle), F.set(e, [
                c,
                d,
                y,
                l,
                i,
                !1
            ])), $;
        } finally{
            o.stackRestore(U), p.forEach((C)=>o._OrtReleaseTensor(C)), w.forEach((C)=>o._OrtReleaseTensor(C)), A.forEach((C)=>o._free(C)), O !== 0 && o._OrtReleaseRunOptions(O), T.forEach((C)=>o._free(C));
        }
    }, Re = (e)=>{
        let t = S(), n = F.get(e);
        if (!n) throw new Error("invalid session id");
        let s = n[0], r = t._OrtEndProfiling(s);
        r === 0 && h("Can't get an profile file name."), t._OrtFree(r);
    };
});
;
var pe, He, je, ze, Ge, qe, Ve, Je, Ye, Xe, ge = P(()=>{
    "use strict";
    $e();
    W();
    Q();
    pe = !1, He = !1, je = !1, ze = async ()=>{
        if (!He) {
            if (pe) throw new Error("multiple calls to 'initWasm()' detected.");
            if (je) throw new Error("previous call to 'initWasm()' failed.");
            pe = !0;
            try {
                await Ie(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm), await De(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"]), He = !0;
            } catch (e) {
                throw je = !0, e;
            } finally{
                pe = !1;
            }
        }
    }, Ge = async (e)=>{
        await Me(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"], e);
    }, qe = async (e)=>de(e), Ve = async (e, t)=>We(e, t), Je = async (e)=>{
        Fe(e);
    }, Ye = async (e, t, n, s, r, a)=>Ne(e, t, n, s, r, a), Xe = async (e)=>{
        Re(e);
    };
});
;
var et, kt, re, tt = P(()=>{
    "use strict";
    ge();
    le();
    K();
    fe();
    et = (e, t)=>{
        switch(e.location){
            case "cpu":
                return [
                    e.type,
                    e.dims,
                    e.data,
                    "cpu"
                ];
            case "gpu-buffer":
                return [
                    e.type,
                    e.dims,
                    {
                        gpuBuffer: e.gpuBuffer
                    },
                    "gpu-buffer"
                ];
            default:
                throw new Error(`invalid data location: ${e.location} for ${t()}`);
        }
    }, kt = (e)=>{
        switch(e[3]){
            case "cpu":
                return new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"](e[0], e[2], e[1]);
            case "gpu-buffer":
                {
                    let t = e[0];
                    if (!te(t)) throw new Error(`not supported data type: ${t} for deserializing GPU tensor`);
                    let { gpuBuffer: n, download: s, dispose: r } = e[2];
                    return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$tensor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"].fromGpuBuffer(n, {
                        dataType: t,
                        dims: e[1],
                        download: s,
                        dispose: r
                    });
                }
            default:
                throw new Error(`invalid data location: ${e[3]}`);
        }
    }, re = class {
        async fetchModelAndCopyToWasmMemory(t) {
            return qe(await q(t));
        }
        async loadModel(t, n) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
            let s;
            typeof t == "string" ? k ? s = await q(t) : s = await this.fetchModelAndCopyToWasmMemory(t) : s = t, [this.sessionId, this.inputNames, this.outputNames] = await Ve(s, n), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])();
        }
        async dispose() {
            return Je(this.sessionId);
        }
        async run(t, n, s) {
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"])();
            let r = [], a = [];
            Object.entries(t).forEach((i)=>{
                let b = i[0], f = i[1], g = this.inputNames.indexOf(b);
                if (g === -1) throw new Error(`invalid input '${b}'`);
                r.push(f), a.push(g);
            });
            let o = [], u = [];
            Object.entries(n).forEach((i)=>{
                let b = i[0], f = i[1], g = this.outputNames.indexOf(b);
                if (g === -1) throw new Error(`invalid output '${b}'`);
                o.push(f), u.push(g);
            });
            let c = r.map((i, b)=>et(i, ()=>`input "${this.inputNames[a[b]]}"`)), d = o.map((i, b)=>i ? et(i, ()=>`output "${this.outputNames[u[b]]}"`) : null), y = await Ye(this.sessionId, a, c, u, d, s), l = {};
            for(let i = 0; i < y.length; i++)l[this.outputNames[u[i]]] = o[i] ?? kt(y[i]);
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$trace$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"])(), l;
        }
        startProfiling() {}
        endProfiling() {
            Xe(this.sessionId);
        }
    };
});
;
var Ut, ne, rt = P(()=>{
    "use strict";
    ge();
    tt();
    Q();
    Ut = ()=>{
        if ((typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.initTimeout != "number" || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.initTimeout < 0) && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.initTimeout = 0), __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.simd === !1 && console.warn('Deprecated property "env.wasm.simd" is set to false. non-SIMD build is no longer provided, and this setting will be ignored.'), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.proxy != "boolean" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.proxy = !1), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace != "boolean" && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.trace = !1), typeof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads != "number" || !Number.isInteger(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads) || __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads <= 0) if (typeof self < "u" && !self.crossOriginIsolated) __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads = 1;
        else {
            let e = typeof navigator > "u" ? se("node:os").cpus().length : navigator.hardwareConcurrency;
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.numThreads = Math.min(4, Math.ceil((e || 1) / 2));
        }
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.wasmPaths === void 0 && D && D.indexOf("blob:") !== 0 && (__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].wasm.wasmPaths = D.substring(0, D.lastIndexOf("/") + 1));
    }, ne = class {
        async init(t) {
            Ut(), await ze(), await Ge(t);
        }
        async createInferenceSessionHandler(t, n) {
            let s = new re;
            return await s.loadModel(t, n), Promise.resolve(s);
        }
    };
});
var nt = {};
mt(nt, {
    wasmBackend: ()=>_t
});
var _t, ot = P(()=>{
    "use strict";
    rt();
    _t = new ne;
});
;
;
;
var Oe = "1.19.0";
var Ur = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__;
{
    let e = (ot(), yt(nt)).wasmBackend;
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"])("cpu", e, 10), (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$backend$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"])("wasm", e, 10);
}Object.defineProperty(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$env$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"].versions, "web", {
    value: Oe,
    enumerable: !0
});
;
 //# sourceMappingURL=ort.node.min.mjs.map
}),
"[project]/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript)", ((__turbopack_context__) => {
"use strict";

__turbopack_context__.s([
    "InferenceSession",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["InferenceSession"],
    "TRACE",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE"],
    "TRACE_FUNC_BEGIN",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_BEGIN"],
    "TRACE_FUNC_END",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TRACE_FUNC_END"],
    "Tensor",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Tensor"],
    "TrainingSession",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["TrainingSession"],
    "default",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["default"],
    "env",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["env"],
    "registerBackend",
    ()=>__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerBackend"]
]);
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$web$2f$dist$2f$ort$2e$node$2e$min$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-web/dist/ort.node.min.mjs [app-ssr] (ecmascript) <locals>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$onnxruntime$2d$common$2f$dist$2f$esm$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/onnxruntime-common/dist/esm/index.js [app-ssr] (ecmascript)");
}),
];

//# sourceMappingURL=node_modules_6063c26e._.js.map